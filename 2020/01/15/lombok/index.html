<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Jehu&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/blog/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/blog/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            lombok注解详解
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一般我们使用的注解的@Retention一般为RUNTIME，对于这种注解，我们只在运行时加载，通过反射获取对应的注解值</p>
<p>lombok的注解采用@Retention的元注解为SOURCE，它会在编译时进行解析，采用的方式是Pluggable Annotation Processing API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">举例来说，现在有一个实现了Pluggable Annotation Processing API的程序A，那么使用javac编译时的具体流程如下：</span><br><span class="line"></span><br><span class="line">1. javac编译器对源码进行分析，生成一个抽象的语法树（AST)</span><br><span class="line"></span><br><span class="line">2. javac编译器运行A程序</span><br><span class="line"></span><br><span class="line">3. A程序完成逻辑，一般是修改此语法树</span><br><span class="line"></span><br><span class="line">4. javac使用修改后的语法树生成可执行的字节码文件</span><br><span class="line"></span><br><span class="line">Lomok便是通过Pluggable Annotation Processing API来实现代码生成的。</span><br></pre></td></tr></table></figure>

<p>关于javac</p>
<h3 id="注解详解"><a href="#注解详解" class="headerlink" title="注解详解"></a>注解详解</h3><p><code>val</code>：用在局部变量前面，相当于将变量声明为final</p>
<p><code>@NonNull</code>：给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）</p>
<p><code>@Cleanup</code>：自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流</p>
<p><code>@Getter/@Setter</code>：用在属性上，再也不用自己手写setter和getter方法了，还可以指定访问范围</p>
<p><code>@ToString</code>：用在类上，可以自动覆写toString方法，当然还可以加其他参数，例如@ToString(exclude=”id”)排除id属性，或者@ToString(callSuper=true, includeFieldNames=true)调用父类的toString方法，包含所有属性</p>
<p><code>@EqualsAndHashCode</code>：用在类上，自动生成equals方法和hashCode方法</p>
<p><code>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</code>：用在类上，自动生成无参构造和使用所有参数的构造函数以及把所有@NonNull属性作为参数的构造函数，如果指定staticName = “of”参数，同时还会生成一个返回类对象的静态工厂方法，比使用构造函数方便很多</p>
<p><code>@Data</code>：注解在类上，相当于同时使用了<code>@ToString</code>、<code>@EqualsAndHashCode</code>、<code>@Getter</code>、<code>@Setter</code>和<code>@RequiredArgsConstrutor</code>这些注解，对于<code>POJO类</code>十分有用</p>
<p><code>@Value</code>：用在类上，是@Data的不可变形式，相当于为属性添加final声明，只提供getter方法，而不提供setter方法</p>
<p><code>@Builder</code>：用在类、构造器、方法上，为你提供复杂的builder APIs，让你可以像如下方式一样调用<code>Person.builder().name(&quot;Adam Savage&quot;).city(&quot;San Francisco&quot;).job(&quot;Mythbusters&quot;).job(&quot;Unchained Reaction&quot;).build();</code>更多说明参考<a href="https://projectlombok.org/features/Builder.html" target="_blank" rel="noopener">Builder</a></p>
<p><code>@SneakyThrows</code>：自动抛受检异常，而无需显式在方法上使用throws语句</p>
<p><code>@Synchronized</code>：用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性<code>$lock</code>或<code>$LOCK</code>，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误</p>
<p><code>@Getter(lazy=true)</code>：可以替代经典的Double Check Lock样板代码</p>
<p><code>@Log</code>：根据不同的注解生成不同类型的log对象，但是实例名称都是log，有六种可选实现类</p>
<ul>
<li><code>@CommonsLog</code> Creates log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);</li>
<li><code>@Log</code> Creates log = java.util.logging.Logger.getLogger(LogExample.class.getName());</li>
<li><code>@Log4j</code> Creates log = org.apache.log4j.Logger.getLogger(LogExample.class);</li>
<li><code>@Log4j2</code> Creates log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);</li>
<li><code>@Slf4j</code> Creates log = org.slf4j.LoggerFactory.getLogger(LogExample.class);</li>
<li><code>@XSlf4j</code> Creates log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);</li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2021 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
    </p>

    
        <a href="http://beian.miit.gov.cn/" target="_blank">浙ICP备18020003号-1</a>
    
    
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/blog/libs/jquery.min.js"></script>


<script src="/blog/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/blog/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>